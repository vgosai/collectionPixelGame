using System;
using System.Collections;
using System.Collections.Generic;
using System.Numerics;
using UnityEngine;
using System.Linq;
using Unity.VisualScripting;
using UnityEditor.Rendering; //used for querying collections and in this case using orderby to extract subset using Guid which is a unique identifyer that we will assign to each value in the hashset then select the guids randomly.

public class CorridorFirstDungeonGeneration : SimpleRandomWalkDungeonGenerator //we extend simplerandomwalk not abstract generator because we are going to use the RunRandomWalk for our corridor generation
{
    [SerializeField]
    private int corridorLength = 14;
    [SerializeField]
    private int corridorCount = 5;
    [SerializeField]
    [Range(0.1f, 1)]
    private float roomPercent = 0.8f;
    private Dictionary<Vector2Int, HashSet<Vector2Int>> roomMapsDictionairy = new Dictionary<Vector2Int, HashSet<Vector2Int>>(); //key is the start position of each rooms generation and the value is that rooms final hashSet
    private HashSet<Vector2Int> floorOnlyMap, corridorPositions; //Hashsets for each room to be used for dictionairy creation and a hashset of all corridor positions generated by the corridor algorithm.
    protected override void RunProceduralGeneration()
    {
        CorridorFirstGeneration();
        foreach (var pos in corridorPositions)
        {
            Debug.Log(pos); // prints "(1, 2)" etc.
        }
    }

    private void CorridorFirstGeneration()
    {
        HashSet<Vector2Int> floorPositions = new HashSet<Vector2Int>();
        HashSet<Vector2Int> potentialRoomPositions = new HashSet<Vector2Int>();
        List<List<Vector2Int>> corridors = CreateCorridors(floorPositions, potentialRoomPositions); //original didnt have potentialroompositions tacked on parameter that does not do anything but is getting the information we need to then create our rooms
        HashSet<Vector2Int> roomPositions = CreateRooms(potentialRoomPositions);
        List<Vector2Int> deadEnds = FindAllDeadEnds(floorPositions);
        CreateRoomsAtDeadEnd(deadEnds, roomPositions); //we pass in roomPositions because maybe createRooms function create a room at the deadend we want to check that
        floorPositions.UnionWith(roomPositions);
        floorOnlyMap = new HashSet<Vector2Int>(floorPositions);
        for (int i = 0; i < corridors.Count; i++)
        {
            //corridors[i] = IncreaseCorridorSizeByOne(corridors[i]);
            corridors[i] = IncreaseCorridorBrush3by3(corridors[i]);
            floorPositions.UnionWith(corridors[i]);

        }
        tilemapVisualizer.PaintFloorTiles(floorPositions);
        WallGenerator.CreateWalls(floorPositions, tilemapVisualizer);
    }

    /// <summary>
    /// Just checks all adjacent tiles to the corridors and adds to them making 3x3.
    /// </summary>
    /// <param name="corridor"></param>
    /// <returns></returns>
    private List<Vector2Int> IncreaseCorridorBrush3by3(List<Vector2Int> corridor)
    {
        List<Vector2Int> newCorridor = new List<Vector2Int>();
        for (int i = 1; i < corridor.Count; i++)
        {
            for (int x = -1; x < 2; x++)
            {
                for (int y = -1; y < 2; y++)
                {
                    newCorridor.Add(corridor[i - 1] + new Vector2Int(x, y));
                }
            }
        }
        return newCorridor;
    }

    private List<Vector2Int> IncreaseCorridorSizeByOne(List<Vector2Int> corridor)
    {
        List<Vector2Int> newCorridor = new List<Vector2Int>();
        Vector2Int previousDirection = Vector2Int.zero;
        for (int i = 1; i < corridor.Count; i++)
        {
            Vector2Int directionFromCell = corridor[i] - corridor[i - 1];
            if (previousDirection != Vector2Int.zero && directionFromCell != previousDirection)
            {
                //handle corner
                for (int x = -1; x < 2; x++)
                {
                    for (int y = -1; y < 2; y++)
                    {
                        newCorridor.Add(corridor[i - 1] + new Vector2Int(x, y));
                    }
                }
                previousDirection = directionFromCell;
            }
            else
            {
                //add a single cell in the direction + 90 degrees
                Vector2Int newCorridorTileOffset = GetDirection90From(directionFromCell);
                newCorridor.Add(corridor[i - 1]);
                newCorridor.Add(corridor[i - 1] + newCorridorTileOffset);
            }
        }
        return newCorridor;
    }

    private Vector2Int GetDirection90From(Vector2Int direction)
    {
        if (direction == Vector2Int.up)
        {
            return Vector2Int.right;
        }
        if (direction == Vector2Int.down)
        {
            return Vector2Int.left;
        }
        if (direction == Vector2Int.right)
        {
            return Vector2Int.down;
        }
        if (direction == Vector2Int.left)
        {
            return Vector2Int.up;
        }
        return Vector2Int.zero;
        
    }
    private void CreateRoomsAtDeadEnd(List<Vector2Int> deadEnds, HashSet<Vector2Int> roomFloors)
    {
        foreach (var position in deadEnds)
        {
            if (roomFloors.Contains(position) == false)
            {
                var room = RunRandomWalk(randomWalkParameters, position);
                roomFloors.UnionWith(room);
            }
        }
    }

    private List<Vector2Int> FindAllDeadEnds(HashSet<Vector2Int> floorPositions)
    {
        List<Vector2Int> deadEnds = new List<Vector2Int>();
        foreach (var position in floorPositions)
        {
            int neighboursCount = 0; //basically just check if there is one neighbor
            foreach (var direction in Direction2D.cardinalDirectionsList)
            {
                if (floorPositions.Contains(position + direction))
                {
                    neighboursCount++;
                }
            }
            if (neighboursCount == 1)
            {
                deadEnds.Add(position);
            }
        }
        return deadEnds;
    }

    private HashSet<Vector2Int> CreateRooms(HashSet<Vector2Int> potentialRoomPositions)
    {
        HashSet<Vector2Int> roomPositions = new HashSet<Vector2Int>();
        int roomToCreateCount = Mathf.RoundToInt(potentialRoomPositions.Count * roomPercent);
        List<Vector2Int> roomToCreate = potentialRoomPositions.OrderBy(x => Guid.NewGuid()).Take(roomToCreateCount).ToList();//Randomize which points on the roomPositions list actually generate a room what this line does is it randomly sorts the list by using the unique Guid for each item in the roomPositions hashset then takes the desired number using the take function then converts to a list so we can iterate through each point and create our room
        foreach (var rooms in roomToCreate)
        {
            var roomFloor = RunRandomWalk(randomWalkParameters, rooms); //This is why we made it so this class inherits from simplerandomwalk because we wanted to use runrandomwalk and we wanted to also use the parameters in the randomwalk generator 
            roomPositions.UnionWith(roomFloor);
        }
        return roomPositions;
    }

    private List<List<Vector2Int>> CreateCorridors(HashSet<Vector2Int> floorPositions, HashSet<Vector2Int> potentialRoomPositions)
    {
        var currentPosition = startPosition;
        potentialRoomPositions.Add(currentPosition);
        List<List<Vector2Int>> corridors = new List<List<Vector2Int>>();
        for (int i = 0; i < corridorCount; i++)
        {
            var corridor = ProceduralGenerationAlgorithms.RandomWalkCorridor(currentPosition, corridorLength);
            corridors.Add(corridor);
            currentPosition = corridor[corridor.Count - 1];//This is where i comes into play the fact that randomwalkcorridor returns a ordered list we take the last entry and set that as the start point for our next corridor.
            potentialRoomPositions.Add(currentPosition);
            floorPositions.UnionWith(corridor); //union to get rid of dupes.
        }
        corridorPositions = new HashSet<Vector2Int>(corridors.SelectMany(inner => inner));
        return corridors;
    }
}
